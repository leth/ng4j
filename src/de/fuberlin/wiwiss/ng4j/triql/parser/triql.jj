/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /Users/richard/WIQA Framework/workspace/NG4J/src/de/fuberlin/wiwiss/ng4j/triql/parser/triql.jj */
/*@egen*//**
 * RDQL - RDF Data Query Language
 *
 * Author:  Andy Seaborne andy_seaborne@hp.com
 * Date:    June 2001
 *
 * (c) Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Hewlett-Packard Development Company, LP
 * All rights reserved.
 * See end of file for details.
 *
 * Constraint expression is derived from Java : 
 * example java1.2-a.jj grammer in JavaCC distribution
 */

options
{
  // Unicode characters outside of 0-0x00FF must be entered as \u1234
  // Javacc does not provide mixed width charactser streams.
  JAVA_UNICODE_ESCAPE   = true;
  UNICODE_INPUT         = false ;

  STATIC                = false ;                                                                                                                                                                                                                                                                                                                                                   
}

PARSER_BEGIN(TriQLParser)
/*
 * (c) Copyright 2001-2008 Hewlett-Packard Development Company, LP
 */

package de.fuberlin.wiwiss.ng4j.triql.parser ; 

public class TriQLParser/*@bgen(jjtree)*/implements TriQLParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTTriQLParserState jjtree = new JJTTriQLParserState();

/*@egen*/
   public SimpleNode top()
   {
      return (SimpleNode)jjtree.rootNode() ;
   }
}
PARSER_END(TriQLParser)


/* WHITE SPACE */

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }
// Need this because we may not be at the start of the identifier
// when the mode is entered.  For URIs, we enter that mode because
// a suitable < is seen, similarly we exit on > so no skip necessary
<READ_IDENTIFIER> SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
//      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  // If octal permitted, should be ["1"-"9"] (["0"-"9"])*
  < #DECIMAL_LITERAL: <DIGITS> >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
/****
 * No character literals
 * And we allow single quoted strings
 */

  < STRING_LITERAL1:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\" ~["\n","\r"])
      )*
      "'"
  >
|
  < STRING_LITERAL2:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"  ~["\n","\r"])
      )*
      "\""
  >
}

// Modes to read things that might be keywords as well.

<READ_URI> TOKEN :
{
      <URI:  ( ~[" ", "\n", "\r", ">", "\t"] )+ >
}

<READ_QNAME> TOKEN :
{
  <QNAME: <QNAME_PREFIX> ":" <QNAME_LNAME>>
|
  <QNAME_PREFIX: (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] )+>
|
  <QNAME_LNAME:  (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] )+>
}

/* To go ...
<READ_IDENTIFIER> TOKEN :
{
  <IDENTIFIER: (<LETTER>|<DIGIT>|"_"|"$"|".")+ >
|
  < LETTER: (["a"-"z"] | ["A"-"Z"])>
|
  < DIGIT:  ["0"-"9"]>
}
*/

/* Keywords : includes operators that are words and should be
 * before general things like IDENTIFIER which swallow almost anything
 */

TOKEN [IGNORE_CASE] :
{
  < SELECT:      "select" >
|
  < SOURCE:      "source" >
|
  < FROM:        "from" >
|
  < WHERE:       "where" >
|
  < SUCHTHAT:    "and" >
|
  < PREFIXES:    "using" >
|
  < FOR:         "for" >
| < STR_EQ: "eq" >
| < STR_NE: "ne" >
| < COUNT: "count" >
}

TOKEN :
{
  < BOOLEAN_LITERAL: "true" | "false" >
|
  < NULL_LITERAL: "null">
|
  < DIGITS: (["0"-"9"])+ >
}

// Notes:
// XML 1.1              http://www.w3.org/TR/xml11/
// XML Namespces 1.1    http://www.w3.org/TR/xml-names11/
//     Prefix ':' LocalPart
//     Prefix is an NCName
//     LocalPart is an NCName
// 
//     // An XML Name, minus the ":"
//     NCName    ::=    NCNameStartChar NCNameChar*
//     NCNameChar         ::=    NameChar - ':' 
//     NCNameStartChar    ::=    NameStartChar - ':' 

//     NameChar and NameSartChar defined in XML 1.1
//     NameStartChar := ":" | [A-Z] | "_" | [a-z] |
//                      [#xC0-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] |
//                      [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
//                      [#x3001-#xD7FF] | [#xF900-#xEFFFF]
//     NameChar      := NameStartChar | "-" | "." | [0-9] | #xB7 |
//                         [#x0300-#x036F] | [#x203F-#x2040]

TOKEN:
{
<NCName: (["A"-"Z"] | "_" | ["a"-"z"]| 
          ["\u00c0"-"\u02ff"] | ["\u0370"-"\u037d"] | ["\u037f"-"\u1fff"] |
	  ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"] |
          ["\u3001"-"\ud7ff"] | ["\uf900"-"\uffff"])

 	 (["A"-"Z"] | "_" | ["a"-"z"]| 
          ["\u00c0"-"\u02ff"] | ["\u0370"-"\u037d"] | ["\u037f"-"\u1fff"] |
	  ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"] |
          ["\u3001"-"\ud7ff"] | ["\uf900"-"\uffff"] |
          "-" | "." | ["0"-"9"] | "\u00b7" |
 	  ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"] )* >

}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  // ASSIGN is here so that the tokenizer will process it and
  // the parser will flag an error.  Otherwise, the tokenizer
  // gives a less helpful message. 
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < NEQ: "!=" >
| < LE: "<=" >    // Maybe: | "=>" >
| < GE: ">=" >    // Maybe: | "=<" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
//| < SC_XOR: "^^" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < BIT_XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
// The tokens for string EQ and string NE are done before IDENTIFIER
// to ensure that they are recognized as reserved words.
| < STR_MATCH: ("=~"|"~~") >
| < STR_NMATCH: "!~">
| < DATATYPE: "^^">
| < AT: "@">
}

// **** Debug point

void CompilationUnit()       :
{}
{
  // The <EOF> tests for trailing junk
  // but does not work for "//...<EOF>"
  Query() <EOF>
}

// Optional comma
void CommaOpt()       :
{}
{
    (<COMMA>)?
}

// **** Debug point

void Query() :
{/*@bgen(jjtree) Query */
  Q_Query jjtn000 = new Q_Query(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Query */
  try {
/*@egen*/
  SelectClause()
  ( SourceClause() )? 
  GraphPatternClause()
  ( ConstraintClause() )?
  ( PrefixesClause() ) ?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SelectClause() :
{/*@bgen(jjtree) SelectClause */
  Q_SelectClause jjtn000 = new Q_SelectClause(JJTSELECTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectClause */
  try {
/*@egen*/
  LOOKAHEAD(2)
  <SELECT> Var() (CommaOpt() Var())*
|
  <SELECT> "*"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SourceClause() :
{/*@bgen(jjtree) SourceClause */
  Q_SourceClause jjtn000 = new Q_SourceClause(JJTSOURCECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SourceClause */
  try {
/*@egen*/
  (<SOURCE> | <FROM>)
  SourceSelector()
  (CommaOpt() SourceSelector() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SourceSelector() :
{/*@bgen(jjtree) SourceSelector */
  Q_SourceSelector jjtn000 = new Q_SourceSelector(JJTSOURCESELECTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SourceSelector */
  try {
/*@egen*/
  // Must be quoted, must be a URL - no qnames at this point.
  URL()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GraphPatternClause() :
{/*@bgen(jjtree) GraphPatternClause */
  Q_GraphPatternClause jjtn000 = new Q_GraphPatternClause(JJTGRAPHPATTERNCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GraphPatternClause */
  try {
/*@egen*/
  <WHERE> GraphPattern() ( CommaOpt() GraphPattern() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ConstraintClause() :
{/*@bgen(jjtree) ConstraintClause */
  Q_ConstraintClause jjtn000 = new Q_ConstraintClause(JJTCONSTRAINTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstraintClause */
  try {
/*@egen*/
  // This comma is not optional - must have comma or "AND"
  <SUCHTHAT> Expression() ( (<COMMA> | <SUCHTHAT> ) Expression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GraphPattern() :
{/*@bgen(jjtree) GraphPattern */
  Q_GraphPattern jjtn000 = new Q_GraphPattern(JJTGRAPHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GraphPattern */
  try {
/*@egen*/
  ( VarOrURI() )? <LPAREN> TriplePattern() ( <DOT> TriplePattern() )* <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TriplePattern() :
{/*@bgen(jjtree) TriplePattern */
  Q_TriplePattern jjtn000 = new Q_TriplePattern(JJTTRIPLEPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TriplePattern */
  try {
/*@egen*/
  VarOrURI() CommaOpt()  VarOrURI() CommaOpt()  VarOrLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VarOrURI()       :
{}
{
  Var() | URI()
}

void VarOrLiteral()       :
{}
{
  Var() | Literal()
}


void Var() :
{/*@bgen(jjtree) Var */
  Q_Var jjtn000 = new Q_Var(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Var */
  try {
/*@egen*/
  "?" Identifier()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void PrefixesClause() : 
{/*@bgen(jjtree) PrefixesClause */
  Q_PrefixesClause jjtn000 = new Q_PrefixesClause(JJTPREFIXESCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) PrefixesClause */
    try {
/*@egen*/
    // Broken: comma should be optional here. But ... it isn't in practice.
    // PrefixDecl starts with an IDENITIFER, read in READ_IDENTIFER 
    // token context but CommaOpt may swallow a comma in DEFAULT tokenizing mode
    // Generated parser seems not to work.

    <PREFIXES> PrefixDecl() ( CommaOpt() PrefixDecl() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrefixDecl() :
{/*@bgen(jjtree) PrefixDecl */
  Q_PrefixDecl jjtn000 = new Q_PrefixDecl(JJTPREFIXDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrefixDecl */
  try {
/*@egen*/
  Identifier() <FOR> QuotedURI()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/******************************************************************/
// Constraint syntax follows.

// **** Debug point

void CountOrExpression()       :
{}
{
  CountExpression()
|
  Expression()
}

void CountExpression() :
{/*@bgen(jjtree) CountExpression */
  Q_CountExpression jjtn000 = new Q_CountExpression(JJTCOUNTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) CountExpression */
  try {
/*@egen*/
  <COUNT> <LPAREN> Var() <RPAREN>
  ( op = <LT> | op = <EQ> | op = <NEQ> | op = <GT> | op = <LE> | op = <GE> )
  { jjtn000.setOperator(op.image); }
  ( NumericLiteral() | TextLiteral() )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/	
}

void Expression()       :
{}
{
  ConditionalOrExpression()
}

void ConditionalOrExpression()       :
{}
{
  ConditionalXorExpression() 
  ( <SC_OR>/*@bgen(jjtree) #LogicalOr( 2) */
            {
              Q_LogicalOr jjtn001 = new Q_LogicalOr(JJTLOGICALOR);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ ConditionalXorExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/ )*
}

void ConditionalXorExpression()       :
{}
{
  ConditionalAndExpression() 
  // Skip this
  //( <SC_XOR> ConditionalAndExpression() #LogicalXor(2) )*
}

void ConditionalAndExpression()       :
{}
{
   ValueLogical()
   ( <SC_AND>/*@bgen(jjtree) #LogicalAnd( 2) */
              {
                Q_LogicalAnd jjtn001 = new Q_LogicalAnd(JJTLOGICALAND);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ ValueLogical()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/ )*
}


// End of boolean expressions

/******************************************************************/

// Things that are not operations on boolean terms.

void ValueLogical()       :
{}
{
  StringEqualityExpression()
}

void StringEqualityExpression()       :
{}
{
  NumericalLogical()
  ( <STR_EQ>/*@bgen(jjtree) #StringEqual( 2) */
             {
               Q_StringEqual jjtn001 = new Q_StringEqual(JJTSTRINGEQUAL);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ NumericalLogical()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
               }
             }
/*@egen*/
  | <STR_NE>/*@bgen(jjtree) #StringNotEqual( 2) */
             {
               Q_StringNotEqual jjtn002 = new Q_StringNotEqual(JJTSTRINGNOTEQUAL);
               boolean jjtc002 = true;
               jjtree.openNodeScope(jjtn002);
             }
             try {
/*@egen*/ NumericalLogical()/*@bgen(jjtree)*/
             } catch (Throwable jjte002) {
               if (jjtc002) {
                 jjtree.clearNodeScope(jjtn002);
                 jjtc002 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte002 instanceof RuntimeException) {
                 throw (RuntimeException)jjte002;
               }
               if (jjte002 instanceof ParseException) {
                 throw (ParseException)jjte002;
               }
               throw (Error)jjte002;
             } finally {
               if (jjtc002) {
                 jjtree.closeNodeScope(jjtn002,  2);
               }
             }
/*@egen*/
  | <STR_MATCH>/*@bgen(jjtree) #StringMatch( 2) */
                 {
                   Q_StringMatch jjtn003 = new Q_StringMatch(JJTSTRINGMATCH);
                   boolean jjtc003 = true;
                   jjtree.openNodeScope(jjtn003);
                 }
                 try {
/*@egen*/  PatternLiteral()/*@bgen(jjtree)*/
                 } catch (Throwable jjte003) {
                   if (jjtc003) {
                     jjtree.clearNodeScope(jjtn003);
                     jjtc003 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte003 instanceof RuntimeException) {
                     throw (RuntimeException)jjte003;
                   }
                   if (jjte003 instanceof ParseException) {
                     throw (ParseException)jjte003;
                   }
                   throw (Error)jjte003;
                 } finally {
                   if (jjtc003) {
                     jjtree.closeNodeScope(jjtn003,  2);
                   }
                 }
/*@egen*/
  | <STR_NMATCH>/*@bgen(jjtree) #StringNoMatch( 2) */
                 {
                   Q_StringNoMatch jjtn004 = new Q_StringNoMatch(JJTSTRINGNOMATCH);
                   boolean jjtc004 = true;
                   jjtree.openNodeScope(jjtn004);
                 }
                 try {
/*@egen*/ PatternLiteral()/*@bgen(jjtree)*/
                 } catch (Throwable jjte004) {
                   if (jjtc004) {
                     jjtree.clearNodeScope(jjtn004);
                     jjtc004 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte004 instanceof RuntimeException) {
                     throw (RuntimeException)jjte004;
                   }
                   if (jjte004 instanceof ParseException) {
                     throw (ParseException)jjte004;
                   }
                   throw (Error)jjte004;
                 } finally {
                   if (jjtc004) {
                     jjtree.closeNodeScope(jjtn004,  2);
                   }
                 }
/*@egen*/
  )*
}

// Expressions that involve comparing numbers.

void NumericalLogical()       :
{}
{
  InclusiveOrExpression()
}

void InclusiveOrExpression()       :
{}
{
  ExclusiveOrExpression()
  ( <BIT_OR>/*@bgen(jjtree) #BitOr( 2) */
             {
               Q_BitOr jjtn001 = new Q_BitOr(JJTBITOR);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ ExclusiveOrExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
               }
             }
/*@egen*/ )*
}

void ExclusiveOrExpression()       :
{}
{
  AndExpression()
  ( <BIT_XOR>/*@bgen(jjtree) #BitXor( 2) */
              {
                Q_BitXor jjtn001 = new Q_BitXor(JJTBITXOR);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ AndExpression()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/ )*
}

void AndExpression()       :
{}
{
  ArithmeticCondition()
  ( <BIT_AND>/*@bgen(jjtree) #BitAnd( 2) */
              {
                Q_BitAnd jjtn001 = new Q_BitAnd(JJTBITAND);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ ArithmeticCondition()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/ )*
}

void ArithmeticCondition()       :
{}
{
  EqualityExpression()
}

void EqualityExpression()       :
{}
{
  RelationalExpression() 
  ( <EQ>/*@bgen(jjtree) #Equal( 2) */
         {
           Q_Equal jjtn001 = new Q_Equal(JJTEQUAL);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/
  | <NEQ>/*@bgen(jjtree) #NotEqual( 2) */
          {
            Q_NotEqual jjtn002 = new Q_NotEqual(JJTNOTEQUAL);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/
  )?
}

void RelationalExpression()       :
{}
{
  NumericExpression()
  ( <LT>/*@bgen(jjtree) #LessThan( 2) */
         {
           Q_LessThan jjtn001 = new Q_LessThan(JJTLESSTHAN);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ NumericExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/
  | <GT>/*@bgen(jjtree) #GreaterThan( 2) */
         {
           Q_GreaterThan jjtn002 = new Q_GreaterThan(JJTGREATERTHAN);
           boolean jjtc002 = true;
           jjtree.openNodeScope(jjtn002);
         }
         try {
/*@egen*/ NumericExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte002) {
           if (jjtc002) {
             jjtree.clearNodeScope(jjtn002);
             jjtc002 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte002 instanceof RuntimeException) {
             throw (RuntimeException)jjte002;
           }
           if (jjte002 instanceof ParseException) {
             throw (ParseException)jjte002;
           }
           throw (Error)jjte002;
         } finally {
           if (jjtc002) {
             jjtree.closeNodeScope(jjtn002,  2);
           }
         }
/*@egen*/
  | <LE>/*@bgen(jjtree) #LessThanOrEqual( 2) */
         {
           Q_LessThanOrEqual jjtn003 = new Q_LessThanOrEqual(JJTLESSTHANOREQUAL);
           boolean jjtc003 = true;
           jjtree.openNodeScope(jjtn003);
         }
         try {
/*@egen*/ NumericExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte003) {
           if (jjtc003) {
             jjtree.clearNodeScope(jjtn003);
             jjtc003 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte003 instanceof RuntimeException) {
             throw (RuntimeException)jjte003;
           }
           if (jjte003 instanceof ParseException) {
             throw (ParseException)jjte003;
           }
           throw (Error)jjte003;
         } finally {
           if (jjtc003) {
             jjtree.closeNodeScope(jjtn003,  2);
           }
         }
/*@egen*/
  | <GE>/*@bgen(jjtree) #GreaterThanOrEqual( 2) */
         {
           Q_GreaterThanOrEqual jjtn004 = new Q_GreaterThanOrEqual(JJTGREATERTHANOREQUAL);
           boolean jjtc004 = true;
           jjtree.openNodeScope(jjtn004);
         }
         try {
/*@egen*/ NumericExpression()/*@bgen(jjtree)*/
         } catch (Throwable jjte004) {
           if (jjtc004) {
             jjtree.clearNodeScope(jjtn004);
             jjtc004 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte004 instanceof RuntimeException) {
             throw (RuntimeException)jjte004;
           }
           if (jjte004 instanceof ParseException) {
             throw (ParseException)jjte004;
           }
           throw (Error)jjte004;
         } finally {
           if (jjtc004) {
             jjtree.closeNodeScope(jjtn004,  2);
           }
         }
/*@egen*/ 
  )?
}

/******************************************************************/

// **** Debug point

void NumericExpression ()        :
{}
{
  ShiftExpression()
}


void ShiftExpression()       :
{}
{
  AdditiveExpression()
  ( <LSHIFT>/*@bgen(jjtree) #LeftShift( 2) */
             {
               Q_LeftShift jjtn001 = new Q_LeftShift(JJTLEFTSHIFT);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
               }
             }
/*@egen*/
  | <RSIGNEDSHIFT>/*@bgen(jjtree) #RightSignedShift( 2) */
                   {
                     Q_RightSignedShift jjtn002 = new Q_RightSignedShift(JJTRIGHTSIGNEDSHIFT);
                     boolean jjtc002 = true;
                     jjtree.openNodeScope(jjtn002);
                   }
                   try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte002) {
                     if (jjtc002) {
                       jjtree.clearNodeScope(jjtn002);
                       jjtc002 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte002 instanceof RuntimeException) {
                       throw (RuntimeException)jjte002;
                     }
                     if (jjte002 instanceof ParseException) {
                       throw (ParseException)jjte002;
                     }
                     throw (Error)jjte002;
                   } finally {
                     if (jjtc002) {
                       jjtree.closeNodeScope(jjtn002,  2);
                     }
                   }
/*@egen*/
  | <RUNSIGNEDSHIFT>/*@bgen(jjtree) #RightUnsignedShift( 2) */
                     {
                       Q_RightUnsignedShift jjtn003 = new Q_RightUnsignedShift(JJTRIGHTUNSIGNEDSHIFT);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                     }
                     try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003,  2);
                       }
                     }
/*@egen*/
  )*
}

void AdditiveExpression()       :
{}
{
  MultiplicativeExpression()
  ( <PLUS>/*@bgen(jjtree) #Add( 2) */
           {
             Q_Add jjtn001 = new Q_Add(JJTADD);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
             }
           }
/*@egen*/
  | <MINUS>/*@bgen(jjtree) #Subtract( 2) */
            {
              Q_Subtract jjtn002 = new Q_Subtract(JJTSUBTRACT);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/
  )*
}

void MultiplicativeExpression()        :
{}
{
  UnaryExpression()
  ( <STAR>/*@bgen(jjtree) #Multiply( 2) */
            {
              Q_Multiply jjtn001 = new Q_Multiply(JJTMULTIPLY);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/
  | <SLASH>/*@bgen(jjtree) #Divide( 2) */
            {
              Q_Divide jjtn002 = new Q_Divide(JJTDIVIDE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/
  | <REM>/*@bgen(jjtree) #Modulus( 2) */
            {
              Q_Modulus jjtn003 = new Q_Modulus(JJTMODULUS);
              boolean jjtc003 = true;
              jjtree.openNodeScope(jjtn003);
            }
            try {
/*@egen*/   UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte003) {
              if (jjtc003) {
                jjtree.clearNodeScope(jjtn003);
                jjtc003 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte003 instanceof RuntimeException) {
                throw (RuntimeException)jjte003;
              }
              if (jjte003 instanceof ParseException) {
                throw (ParseException)jjte003;
              }
              throw (Error)jjte003;
            } finally {
              if (jjtc003) {
                jjtree.closeNodeScope(jjtn003,  2);
              }
            }
/*@egen*/
  )*
}

void UnaryExpression()       :
{}
{
  UnaryExpressionNotPlusMinus()
|
  ( <PLUS>/*@bgen(jjtree) #UnaryPlus( 1) */
            {
              Q_UnaryPlus jjtn001 = new Q_UnaryPlus(JJTUNARYPLUS);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  1);
              }
            }
/*@egen*/
  | <MINUS>/*@bgen(jjtree) #UnaryMinus( 1) */
            {
              Q_UnaryMinus jjtn002 = new Q_UnaryMinus(JJTUNARYMINUS);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  1);
              }
            }
/*@egen*/
  )
}

void UnaryExpressionNotPlusMinus()       :
{}
{
  ( <TILDE> | <BANG> )/*@bgen(jjtree) #UnaryNot( 1) */
                       {
                         Q_UnaryNot jjtn001 = new Q_UnaryNot(JJTUNARYNOT);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
                       }
                       try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte001) {
                         if (jjtc001) {
                           jjtree.clearNodeScope(jjtn001);
                           jjtc001 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte001 instanceof RuntimeException) {
                           throw (RuntimeException)jjte001;
                         }
                         if (jjte001 instanceof ParseException) {
                           throw (ParseException)jjte001;
                         }
                         throw (Error)jjte001;
                       } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  1);
                         }
                       }
/*@egen*/
|
  PrimaryExpression()
}

void PrimaryExpression()       :
{}
{
  Var()
|
  Literal()
|
//  FunctionCall()
//|
  // And this is why expressions are not typed by the parser!
  // Arbitrary lookahead of chars to see is the expression
  // is numeric or boolean.
  <LPAREN> Expression() <RPAREN>
}

// void FunctionCall() :
// {}
// {
//   Identifier() <LPAREN> ArgList() <RPAREN>
// }
// 
// void ArgList() :
// {}
// {
//   VarOrLiteral() (<COMMA> VarOrLiteral() ) *
// }


/******************************************************************/
// Literals (as in query literls - any value in the query
// Not "RDF literals".

void Literal()       :
{}
{
  URI()
|
  NumericLiteral()
|
  TextLiteral()
|
  BooleanLiteral()
|
  NullLiteral()
}

void NumericLiteral() :
{/*@bgen(jjtree) NumericLiteral */
  Q_NumericLiteral jjtn000 = new Q_NumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) NumericLiteral */
  try {
/*@egen*/
  t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.set(true, t.image) ; }
|
  t = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ { jjtn000.set(false, t.image) ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TextLiteral() :
{/*@bgen(jjtree) TextLiteral */
  Q_TextLiteral jjtn000 = new Q_TextLiteral(JJTTEXTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t ;
}
{/*@bgen(jjtree) TextLiteral */
  try {
/*@egen*/
  ( t = <STRING_LITERAL1> { jjtn000.set(t.image) ; }
  | t = <STRING_LITERAL2> { jjtn000.set(t.image) ; } )

  // Optional lang tag and datatype.

  ( <AT> Identifier() ) ?
  ( <DATATYPE> URI() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
} 




<READ_REGEX> TOKEN :
{
    // This just creates a token symbol to read a character- we fill it in Java below.
    // Doing it like this means we use the parser token routines, not the tokenizer directly.
    <PATTERN: ~[]>
}
//<READ_REGEX> SKIP : { " " | "\t" | "\n" | "\r" | "\f" }


void PatternLiteral() :
{/*@bgen(jjtree) PatternLiteral */
  Q_PatternLiteral jjtn000 = new Q_PatternLiteral(JJTPATTERNLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t ;
  Token mtoken ;
  char marker ;
  int state = 0 ;
}
{/*@bgen(jjtree) PatternLiteral */
  try {
/*@egen*/
  // Skip whitespace

  {
    state = token_source.curLexState ;
    token_source.SwitchTo(READ_REGEX) ;
  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
   
  // Pattern language is: [m]/pattern/[i][m][s][x]
  // Note the leading "m" is optional because // is
  // often in conflict with URIs so the convenience
  // of, say "!", as a leading marker is good.
  // We do check that the RE isn't "....", i.e. markers, with
  // no "m", that might be a plain string.
    
  // Having a variable marker is tricky because we can't
  // define the pattern in fixed tokens.  But the target is simple
  // so we just do it in java.
  // Skip to marker char (processing escapes)

  {
      while(true)
      {
	  t = getNextToken() ;
	  if ( t.kind == EOF )
	      throw new Error("End of file: expecting the start of a regular expression") ;
	  marker = t.image.charAt(0) ;
	  // Skip whitespace
	  if ( marker != ' ' && marker != '\n' && 
	       marker != '\t' && marker != '\r' &&
	       marker != '\f' )
	      break ;
      }
      if ( marker != '/' )
      {
	  if ( marker == 'm' )
	  {
	      //marker = jj_input_stream.readChar() ;
	      t = getNextToken() ;
	      marker = t.image.charAt(0) ;
	  }
	  else
          {
              if ( marker == '"' || marker == '\'' )
                  // Does not start m, and does start with " or '
                  throw new Error("Invalid regular expression (starts with ["+marker+"]) at line " +
		      t.beginLine + " column " + t.beginColumn + ".");
	  }
          // Sanity check - delimiter isn't an alphanumeric
	  if ( Character.isLetterOrDigit(marker) )
	      throw new Error("Invalid start to regular expression at line " +
			      t.beginLine + " column " + t.beginColumn + ".");
      }
      String patternString = "" ;
      boolean inEscape = false ;
      while(true)
      {
	  char ch ;
	  t = getNextToken() ;
	  if ( t.kind == EOF )
	      throw new Error("End of file during regular expression") ;
	  ch = t.image.charAt(0) ;
	  
	  if ( ch == '\n' || ch == '\r' || ch == '\f' )
	      throw new Error("Invalid regular expression at line " +
			      t.beginLine + " column " + t.beginColumn + ".");
	  if ( inEscape )
	  {
	      if ( ch == 'n' ) ch = '\n' ;
	      if ( ch == 't' ) ch = '\t' ;
	      if ( ch == 'r' ) ch = '\r' ;
	      if ( ch == 'b' ) ch = '\b' ;

	      // But if we are escaping a character that is regex significant,
	      // leave in the esacape.
	      if ( ch != marker )
		  patternString = patternString + '\\' ;

	      inEscape = false ;
	  }
	  else
	  {
	      // Escape?
	      if ( ch == '\\' )
	      {
		  inEscape = true ;
		  continue ;
	      }
	      if ( ch == marker )
		  break ;
	      
	  }
	  patternString = patternString + ch ;
      }
      // Read modifiers
      String modifiers = "" ;
      while(true)
      {
	  char ch ;
	  // End of file possible.
	  t = getNextToken() ;
	  if ( t.kind == EOF )
	      break ;
	  ch = t.image.charAt(0) ;
	  
	  if ( ch == 'i' || ch == 'm' || ch == 's' || ch == 'x' )
	      modifiers = modifiers + ch ;
	  else
	  {
	      jj_input_stream.backup(1) ;
	      break ;
	  }
      }
      
      token_source.SwitchTo(state) ;
      jjtn000.setPattern(patternString) ;
      if ( modifiers.length() > 0 )
	  jjtn000.setModifiers(modifiers) ; 
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void BooleanLiteral() :
{/*@bgen(jjtree) BooleanLiteral */
  Q_BooleanLiteral jjtn000 = new Q_BooleanLiteral(JJTBOOLEANLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t ;
}
{/*@bgen(jjtree) BooleanLiteral */
  try {
/*@egen*/
  t = <BOOLEAN_LITERAL>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/  { jjtn000.set(t.image) ; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void NullLiteral() :
{/*@bgen(jjtree) NullLiteral */
  Q_NullLiteral jjtn000 = new Q_NullLiteral(JJTNULLLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NullLiteral */
  try {
/*@egen*/
  <NULL_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void URL() :
{/*@bgen(jjtree) URL */
  Q_URL jjtn000 = new Q_URL(JJTURL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) URL */
  try {
/*@egen*/
  QuotedURI()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void URI()       :
{ }
{
  QuotedURI()
|
  QName()
}

void QName() :
{/*@bgen(jjtree) QName */
  Q_QName jjtn000 = new Q_QName(JJTQNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1, t2 ; }
{/*@bgen(jjtree) QName */
    try {
/*@egen*/
    //<Prefix> ":" (<LocalPart>) { jjtThis.set(token.image) ; }
    Identifier() 
    { t1 = token ; }
    ":" (LOOKAHEAD(2) Identifier())?/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { t2 = token ;
      jjtn000.set(t1.image+":"+t2.image) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void QuotedURI() :
{/*@bgen(jjtree) QuotedURI */
  Q_QuotedURI jjtn000 = new Q_QuotedURI(JJTQUOTEDURI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token tt = null ;
  int state = 0 ;
}
{/*@bgen(jjtree) QuotedURI */
  try {
/*@egen*/
  "<"
  {
    state = token_source.curLexState ;
    token_source.SwitchTo(READ_URI) ; 
  }
  tt = <URI>
  { 
    jjtn000.set(tt.image) ;
    token_source.SwitchTo(state) ;
  }
  ">"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



// Need to generalise this to include leading digits
// That is, the second part of an NCName expressions

void Identifier() :
{/*@bgen(jjtree) Identifier */
  Q_Identifier jjtn000 = new Q_Identifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
   try {
/*@egen*/
   ( //<IDENTIFIER> 
    <NCName>
    // And all keywords
    | <SELECT> | <SOURCE> | <FROM> | <WHERE>
// Cause choice conflict between graph name QName and following AND or USING clause
//    | <SUCHTHAT> | <PREFIXES>
    | <FOR>
    | <STR_EQ> | <STR_NE> )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.set(token.image) ; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


/*
 * (c) Copyright 2001-2008 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
