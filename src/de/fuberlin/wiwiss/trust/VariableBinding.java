package de.fuberlin.wiwiss.trust;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.Node;

/**
 * <p>A mapping from variable names (strings) to RDF nodes.</p>
 * 
 * <p>Additionally, a binding may contain zero or more
 * {@link ExplanationPart}s and zero or more {@link Graph}s containing
 * graph explanations. Metric plugins use this facility to store
 * their explanations in the binding after having checked that
 * the binding fulfills the metric.</p>
 * 
 * @version $Id: VariableBinding.java,v 1.5 2005/10/04 00:03:44 cyganiak Exp $
 * @author Richard Cyganiak (richard@cyganiak.de)
 * @author Oliver Maresch (oliver-maresch@gmx.de)
 */
public class VariableBinding {
    private Map namesToValues;
    
    /** Contains a list of  ExplanationPart generated by the contstraint checking.*/
    private List textExplanations;

    /** Contains a list of  Graphs with RDF explanations generated by the contstraint checking.*/
    private List graphExplanations;

    public VariableBinding() {
        this(new HashMap());
    }
    
    public VariableBinding(Map binding) {
        this.namesToValues = binding;
        this.textExplanations = new ArrayList();
        this.graphExplanations = new ArrayList();
    }
    
    /**
     * Adds a ExplanationPart to the list of text explanations.
     * @param textExplanation The explanation part to be added
     */
    public void addTextExplanation(ExplanationPart textExplanation){
        this.textExplanations.add(textExplanation);
    }
    
    /** 
     * @return A list of {@link ExplanationPart}s
     */
    public List getTextExplanations(){
        return this.textExplanations;
    }
    
    /**
     * Adds a Graph with an RDF Explanation to the list of
     * graph explanations.
     * @param graphExplanation The RDF graph containing the explanation
     */
    public void addGraphExplanation(Graph graphExplanation){
        this.graphExplanations.add(graphExplanation);
    }
    
    /** 
     * @return A list of {@link Graph}s containing graph explanations
     */
    public List getGraphExplanations(){
        return this.graphExplanations;
    }
    
    /**
     * @param variableName A variable name
     * @return true if it is bound
     */
    public boolean containsName(String variableName) {
        return this.namesToValues.containsKey(variableName);
    }

    /**
     * @param variableName A variable name
     * @return Its value, or null if it is not bound
     */
    public Node value(String variableName) {
        return (Node) this.namesToValues.get(variableName);
    }
    
    /**
     * Sets the value of a variable.
     * @param variableName A variable name
     * @param variableValue Its new value
     */
    public void setValue(String variableName, Node variableValue) {
        this.namesToValues.put(variableName, variableValue);
    }
    
    /**
     * @return A set of strings containing all bound variable names
     */
    public Set variableNames() {
        return this.namesToValues.keySet();
    }
    
    /**
     * @return A Java {@link Map} representation of the binding
     */
    public Map asMap() {
        return Collections.unmodifiableMap(this.namesToValues);
    }
    
    /**
     * @param variableNames A set of variable names (strings)
     * @return A new binding containing only those variables that were
     * 		bound in the original and are in the argument collection
     */
    public VariableBinding selectSubset(Collection variableNames) {
        VariableBinding result = new VariableBinding();
        Iterator it = variableNames.iterator();
        while (it.hasNext()) {
            String variableName = (String) it.next();
            if (!containsName(variableName)) {
                continue;
            }
            result.setValue(variableName, value(variableName));
        }
        return result;
    }
    
    /**
     * @param other Another binding
     * @return True if all variables of this binding are bound to
     * 		the same values in the other binding
     */
    public boolean isSubsetOf(VariableBinding other) {
        Iterator it = this.namesToValues.keySet().iterator();
        while (it.hasNext()) {
            String variableName = (String) it.next();
            Node value = value(variableName);
            if (value == null && other.value(variableName) != null) {
                return false;
            }
            if (value != null && !value.equals(other.value(variableName))) {
                return false;
            }
        }
        return true;
    }
    
    public String toString() {
        return "VariableBinding" + this.namesToValues;
    }
    
    public boolean equals(Object other) {
        VariableBinding otherBinding = (VariableBinding) other;
        return otherBinding.namesToValues.equals(this.namesToValues);
    }
    
    public int hashCode() {
        return this.namesToValues.hashCode();
    }
}
